<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML</title>
    <!-- Enlace a Tailwind CSS para las clases de la estructura HTML -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    
    <!-- CSS completo para el estilo del quiz -->
    <style>
        /* Estilos generales del cuerpo */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }

        /* Contenedor principal del quiz */
        .container {
            background-color: #ffffff;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            padding: 30px;
            max-width: 800px;
            width: 100%;
            margin-top: 20px;
        }

        /* Tarjeta de la pregunta */
        .question-card {
            background-color: #f8fafc;
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 20px;
            border: 1px solid #e2e8f0;
            transition: all 0.3s ease-in-out;
        }

        /* Estilo para la tarjeta de pregunta correcta */
        .question-card.correct {
            background-color: #d4edda;
            border-color: #28a745;
        }

        /* Estilo para la tarjeta de pregunta incorrecta */
        .question-card.incorrect {
            background-color: #f8d7da;
            border-color: #dc3545;
        }

        /* Texto de la pregunta */
        .question-text {
            font-size: 1.15rem;
            font-weight: 600;
            color: #2d3748;
            margin-bottom: 15px;
            line-height: 1.5;
        }

        /* Botones de opciones */
        .option-button {
            display: block;
            width: 100%;
            text-align: left;
            padding: 12px 18px;
            margin-bottom: 10px;
            border-radius: 8px;
            border: 1px solid #cbd5e0;
            background-color: #ffffff;
            color: #4a5568;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }

        /* Efecto hover para los botones de opciones */
        .option-button:hover:not(.disabled) {
            background-color: #e2e8f0;
            border-color: #a0aec0;
        }

        /* Estilo para el botón de opción seleccionado */
        .option-button.selected {
            border-color: #4299e1;
            background-color: #ebf8ff;
            font-weight: 600;
        }

        /* Estilo para la respuesta correcta */
        .option-button.correct-answer {
            background-color: #28a745;
            color: #ffffff;
            border-color: #28a745;
            font-weight: 700;
        }

        /* Estilo para la respuesta incorrecta */
        .option-button.incorrect-answer {
            background-color: #dc3545;
            color: #ffffff;
            border-color: #dc3545;
            font-weight: 700;
        }

        /* Estilo para los botones deshabilitados */
        .option-button.disabled {
            cursor: not-allowed;
            opacity: 0.8;
        }

        /* Contenedor de la solución */
        .solution {
            margin-top: 15px;
            padding: 10px 15px;
            border-radius: 8px;
            background-color: #e0f2f7;
            color: #2c5282;
            font-size: 0.95rem;
            font-weight: 500;
            border: 1px solid #90cdf4;
        }

        /* Contenedor del feedback (correcto/incorrecto) */
        .feedback {
            margin-top: 15px;
            font-weight: 600;
            font-size: 1rem;
            text-align: center;
        }

        /* Estilo para feedback correcto */
        .feedback.correct {
            color: #28a745;
        }

        /* Estilo para feedback incorrecto */
        .feedback.incorrect {
            color: #dc3545;
        }

        /* Contenedor de los botones de navegación */
        .navigation-buttons {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 30px;
            flex-wrap: wrap;
            gap: 10px;
        }

        /* Estilo base para los botones de navegación */
        .nav-button {
            padding: 12px 25px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            flex-grow: 1;
            text-align: center;
        }

        /* Estilo para el botón "Anterior" */
        .nav-button.prev {
            background-color: #6b7280;
            color: #ffffff;
        }
        .nav-button.prev:hover:not(:disabled) {
            background-color: #4b5563;
            transform: translateY(-2px);
        }

        /* Estilo para el botón "Siguiente" */
        .nav-button.next {
            background-color: #4299e1;
            color: #ffffff;
        }
        .nav-button.next:hover:not(:disabled) {
            background-color: #3182ce;
            transform: translateY(-2px);
        }

        /* Estilo para el botón de reinicio en línea */
        .nav-button.restart-inline {
            background-color: #f50b0b;
            color: #ffffff;
        }
        .nav-button.restart-inline:hover:not(:disabled) {
            background-color: #ac0505;
            transform: translateY(-2px);
        }

        /* Estilo para los botones deshabilitados */
        .nav-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Barra de progreso */
        .progress-bar-container {
            width: 100%;
            background-color: #e2e8f0;
            border-radius: 5px;
            height: 10px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background-color: #4299e1;
            width: 0%;
            border-radius: 5px;
            transition: width 0.3s ease-in-out;
        }

        /* Visualización de la puntuación final */
        .score-display {
            text-align: center;
            font-size: 1.5rem;
            font-weight: 700;
            color: #2d3748;
            margin-top: 20px;
        }

        /* Resumen de resultados */
        .results-summary {
            margin-top: 20px;
            padding: 20px;
            background-color: #f8fafc;
            border-radius: 10px;
            border: 1px solid #e2e8f0;
        }

        .results-summary p {
            font-size: 1.1rem;
            margin-bottom: 8px;
            color: #2d3748;
        }

        .results-summary p strong {
            font-weight: 700;
        }

        /* Botón de reinicio final */
        .restart-button {
            display: block;
            width: fit-content;
            margin: 20px auto 0 auto;
            padding: 12px 30px;
            background-color: #48bb78;
            color: #ffffff;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }

        .restart-button:hover {
            background-color: #38a169;
            transform: translateY(-2px);
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
         <h1 style="color: #003366; font-family: 'Georgia', serif; font-size: 3rem; text-align: center; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);">XML</h1>

        <!-- Barra de progreso -->
        <div class="progress-bar-container">
            <div id="progressBar" class="progress-bar"></div>
        </div>

        <!-- Contenedor principal de las preguntas -->
        <div id="quizContainer">
            <!-- Las preguntas se cargarán dinámicamente aquí -->
        </div>

        <!-- Botones de navegación -->
        <div class="navigation-buttons">
            <button id="prevBtn" class="nav-button prev" disabled>Anterior</button>
            <button id="restartInlineBtn" class="nav-button restart-inline">Reiniciar Test</button>
            <button id="nextBtn" class="nav-button next">Siguiente</button>
        </div>

        <!-- Contenedor de la puntuación final -->
        <div id="finalScore" class="hidden">
            <div class="score-display"></div>
            <div class="results-summary">
                <p><strong>Preguntas Correctas:</strong> <span id="correctCount">0</span></p>
                <p><strong>Preguntas Incorrectas:</strong> <span id="incorrectCount">0</span></p>
                <p><strong>Preguntas Sin Contestar:</strong> <span id="unansweredCount">0</span></p>
            </div>
            <button id="restartBtn" class="restart-button">Reiniciar Test</button>
        </div>
    </div>
    <script>
        const quizData = [



            {
                question: "¿De dónde deriva el estándar XML?",
                options: ["a) HTML", "b) SGML", "c) JSON", "d) DTD"],
                correctAnswer: "b) SGML"
            },
            {
                question: "¿Cuál de las siguientes afirmaciones describe una de las utilidades de XML?",
                options: ["a) Simplificar el diseño gráfico de páginas web.", "b) Estructurar la información de configuración.", "c) Acelerar la transmisión de datos sin estructurar.", "d) Definir la lógica de programación de aplicaciones."],
                correctAnswer: "b) Estructurar la información de configuración."
            },
            {
                question: "¿Qué restricción impone XML sobre SGML en relación con las etiquetas?",
                options: ["a) Todas las etiquetas deben ser de cierre automático.", "b) Las etiquetas de apertura son opcionales.", "c) Todas las etiquetas deben llevar cierre (incluso empty elements).", "d) Solo las etiquetas raíz necesitan cierre."],
                correctAnswer: "c) Todas las etiquetas deben llevar cierre (incluso empty elements)."
            },
            {
                question: "¿Cómo deben ir los valores de los atributos en XML?",
                options: ["a) Sin comillas.", "b) Entre comillas simples.", "c) Entre comillas dobles.", "d) Entre comillas simples o dobles."],
                correctAnswer: "d) Entre comillas simples o dobles."
            },
            {
                question: "¿XML es sensible a mayúsculas y minúsculas (Case-Sensitive)?",
                options: ["a) Sí.", "b) No.", "c) Solo en los nombres de los elementos.", "d) Solo en los valores de los atributos."],
                correctAnswer: "a) Sí."
            },
            {
                question: "¿Cuál de los siguientes estaba completamente alineado con SGML?",
                options: ["a) HTML5", "b) XHTML", "c) HTML4", "d) XML"],
                correctAnswer: "c) HTML4"
            },
            {
                question: "¿Cuál de los siguientes estaba basado en las reglas de XML?",
                options: ["a) HTML4", "b) HTML5", "c) XHTML", "d) SGML"],
                correctAnswer: "c) XHTML"
            },
            {
                question: "En una declaración XML <?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?>, ¿cuál de los atributos es obligatorio?",
                options: ["a) encoding", "b) standalone", "c) version", "d) Ninguno."],
                correctAnswer: "c) version"
            },
            {
                question: "¿Qué indica el atributo standalone=\"no\" en la declaración XML?",
                options: ["a) Que el XML no es válido.", "b) Que el DTD está en un fichero externo.", "c) Que la gramática está contenida en el mismo XML.", "d) Que el documento no necesita una gramática."],
                correctAnswer: "b) Que el DTD está en un fichero externo."
            },
            {
                question: "Si la gramática de un XML está contenida en el mismo fichero XML y no necesita DTD, ¿qué valor debería tener el atributo standalone?",
                options: ["a) no", "b) yes", "c) external", "d) internal"],
                correctAnswer: "b) yes"
            },
            {
                question: "¿Cuál es el valor por defecto del atributo standalone en la declaración XML?",
                options: ["a) yes", "b) no", "c) true", "d) false"],
                correctAnswer: "b) no"
            },
            {
                question: "¿Qué es &amp; en XML y qué lo sustituye el analizador XML?",
                options: ["a) Es un comentario; lo elimina.", "b) Es un espacio de nombres; lo interpreta como un prefijo.", "c) Es un entity macro escape; lo sustituye por \"&amp;\".", "d) Es un atributo; lo considera un valor."],
                correctAnswer: "c) Es un entity macro escape; lo sustituye por \"&amp;\"."
            },
            {
                question: "¿Qué efecto tiene <![CDATA[texto que el parser no analiza]]> en un documento XML?",
                options: ["a) El analizador lo ignora completamente.", "b) El analizador lo interpreta como un comentario.", "c) El analizador no lo interpreta y lo devuelve literalmente.", "d) El analizador lo convierte a entidades HTML."],
                correctAnswer: "c) El analizador no lo interpreta y lo devuelve literalmente."
            },
            {
                question: "Un \"empty element\" en XML:",
                options: ["a) No puede tener atributos ni hijos.", "b) No puede tener hijos pero sí atributos.", "c) Puede tener hijos pero no atributos.", "d) Debe contener texto plano."],
                correctAnswer: "b) No puede tener hijos pero sí atributos."
            },
            {
                question: "¿Para qué se utilizan los espacios de nombres en XML?",
                options: ["a) Para mejorar el rendimiento del análisis sintáctico.", "b) Para permitir la inclusión de prefijos en las etiquetas y evitar duplicados de nombres.", "c) Para indicar la codificación de caracteres del documento.", "d) Para definir la versión del estándar XML utilizado."],
                correctAnswer: "b) Para permitir la inclusión de prefijos en las etiquetas y evitar duplicados de nombres."
            },
            {
                question: "¿Los DTDs dan soporte a los espacios de nombres?",
                options: ["a) Sí, completamente.", "b) No, no dan soporte a los espacios de nombres.", "c) Solo si se utiliza una versión específica de DTD.", "d) Solo para atributos, no para elementos."],
                correctAnswer: "b) No, no dan soporte a los espacios de nombres."
            },
            {
                question: "Para que un documento XML se considere \"Bien Formado\", ¿cuántos elementos raíz debe contener?",
                options: ["a) Cero o uno.", "b) Exactamente uno.", "c) Uno o más.", "d) Puede contener varios, siempre que estén anidados."],
                correctAnswer: "b) Exactamente uno."
            },
            {
                question: "¿Cómo deben ir los valores de atributos en un XML \"Bien Formado\"?",
                options: ["a) Sin comillas.", "b) Entre comillas simples.", "c) Entre comillas dobles.", "d) Entre comillas simples o dobles."],
                correctAnswer: "d) Entre comillas simples o dobles."
            },
            {
                question: "¿Cómo terminan los elementos vacíos en un XML \"Bien Formado\"?",
                options: ["a) Con una etiqueta de apertura y sin cierre.", "b) Con una etiqueta de fin explícita.", "c) Con \"/\" (autocierre) o etiqueta de fin.", "d) Depende del tipo de documento."],
                correctAnswer: "c) Con \"/\" (autocierre) o etiqueta de fin."
            },
            {
                question: "¿Con qué caracteres pueden comenzar las etiquetas XML?",
                options: ["a) Con cualquier carácter alfanumérico.", "b) Con una letra, un número o un guion.", "c) Con una letra, \"_\" o \":\".", "d) Solo con letras mayúsculas."],
                correctAnswer: "c) Con una letra, \"_\" o \":\"."
            },
            {
                question: "¿Qué significa que un documento XML sea \"Válido\"?",
                options: ["a) Que cumple con la sintaxis XML.", "b) Que ha sido aprobado por la W3C.", "c) Que está bien formado y además cumple con las reglas de la gramática (DTD/XSD).", "d) Que ha sido generado por un procesador XML oficial."],
                correctAnswer: "c) Que está bien formado y además cumple con las reglas de la gramática (DTD/XSD)."
            },
            {
                question: "¿Qué significan las siglas DTD y XSD?",
                options: ["a) Document Type Definition / XML Style Description", "b) Data Type Definition / XML Syntax Definition", "c) Document Type Definition / XML Schema Definition", "d) Data Transformation Document / XML Standard Document"],
                correctAnswer: "c) Document Type Definition / XML Schema Definition"
            },
            {
                question: "¿Cuál de las siguientes afirmaciones es correcta respecto a la definición de la estructura/gramática con DTD y XSD?",
                options: ["a) DTD es más flexible en definición de tipos de datos que XSD.", "b) XSD fue la primera y es menos flexible.", "c) DTD no especifica tipos de datos.", "d) XSD no permite definir restricciones a los valores."],
                correctAnswer: "c) DTD no especifica tipos de datos."
            },
            {
                question: "En un DTD, ¿qué indica (#PCDATA) como tipo de contenido de un elemento?",
                options: ["a) Que el elemento contiene cualquier tipo de dato.", "b) Que el elemento contiene solo texto.", "c) Que el elemento está vacío.", "d) Que el elemento contiene otros elementos."],
                correctAnswer: "b) Que el elemento contiene solo texto."
            },
            {
                question: "En un DTD, si un elemento puede contener una mezcla de etiquetas y textos, ¿qué tipo de contenido se usaría?",
                options: ["a) #PCDATA", "b) EMPTY", "c) ANY", "d) CDATA"],
                correctAnswer: "c) ANY"
            },
            {
                question: "En un DTD, ¿qué tipo de atributo se utiliza para una clave primaria?",
                options: ["a) CDATA", "b) IDREF", "c) ID", "d) NMTOKEN"],
                correctAnswer: "c) ID"
            },
            {
                question: "En un DTD, si un atributo es opcional, ¿qué palabra clave se utiliza?",
                options: ["a) #REQUIRED", "b) #FIXED", "c) #IMPLIED", "d) #OPTIONAL"],
                correctAnswer: "c) #IMPLIED"
            },
            {
                question: "En un DTD, si un atributo debe tener un valor fijo, ¿qué palabra clave se utiliza?",
                options: ["a) #IMPLIED", "b) #REQUIRED", "c) #FIXED", "d) #DEFAULT"],
                correctAnswer: "c) #FIXED"
            },
            {
                question: "¿Qué indica el operador * en la definición de un elemento dentro de un DTD (ej. (futbol | f1 | tenis)*)?",
                options: ["a) Que el elemento debe aparecer al menos una vez.", "b) Que el elemento puede aparecer cero o una vez.", "c) Que el elemento puede aparecer cero o muchas veces.", "d) Que el elemento debe aparecer exactamente una vez."],
                correctAnswer: "c) Que el elemento puede aparecer cero o muchas veces."
            },
            {
                question: "¿Qué indica el operador + en la definición de un elemento dentro de un DTD?",
                options: ["a) Cero o muchas ocurrencias.", "b) Cero o una ocurrencia.", "c) Una o muchas ocurrencias.", "d) Exactamente una ocurrencia."],
                correctAnswer: "c) Una o muchas ocurrencias."
            },
            {
                question: "¿Qué indica el operador ? en la definición de un elemento dentro de un DTD?",
                options: ["a) Cero o muchas ocurrencias.", "b) Cero o una ocurrencia.", "c) Una o muchas ocurrencias.", "d) Exactamente una ocurrencia."],
                correctAnswer: "b) Cero o una ocurrencia."
            },
            {
                question: "En un XSD, la definición de un tipo a partir de otro se logra mediante:",
                options: ["a) xs:restriction", "b) xs:extension base", "c) xs:union", "d) xs:list"],
                correctAnswer: "b) xs:extension base"
            },
            {
                question: "¿Qué atributo se utiliza en un esquema XML (XSD) para enlazar el fichero de datos con la gramática, dando de alta el espacio de nombres XML Schema Instance?",
                options: ["a) xsi:schemaLocation", "b) xmlns:xsi", "c) xsi:noNamespaceSchemaLocation", "d) xml:link"],
                correctAnswer: "b) xmlns:xsi"
            },
            {
                question: "¿Qué valor del atributo minOccurs en un XSD indica que una ocurrencia es obligatoria si no se especifica?",
                options: ["a) 0", "b) 1", "c) unbounded", "d) required"],
                correctAnswer: "b) 1"
            },
            {
                question: "¿Qué significa pattern value=\"[CER]\" en la restricción de un tipo simple en XSD?",
                options: ["a) Que el valor debe contener la secuencia \"CER\".", "b) Que el valor puede ser \"C\", \"E\" o \"R\".", "c) Que el valor debe ser un número entre C, E y R.", "d) Que el valor debe ser una cadena con al menos uno de esos caracteres."],
                correctAnswer: "b) Que el valor puede ser \"C\", \"E\" o \"R\"."
            },
            {
                question: "¿Cómo deben ir los valores de los atributos en un XML según un XSD?",
                options: ["a) Sin comillas.", "b) Entre comillas simples.", "c) Entre comillas dobles.", "d) Siempre entre comillas."],
                correctAnswer: "d) Siempre entre comillas."
            },
            {
                question: "¿Cuál es el propósito principal de las Transformaciones XSL?",
                options: ["a) Validar documentos XML.", "b) Transformar datos XML.", "c) Generar gráficos a partir de datos XML.", "d) Cifrar documentos XML."],
                correctAnswer: "b) Transformar datos XML."
            },
            {
                question: "Según el documento, ¿las Transformaciones XSL están obsoletas?",
                options: ["a) No, son una tecnología de vanguardia.", "b) Sí, ya están obsoletas.", "c) Solo en ciertas implementaciones.", "d) Solo para formatos de salida específicos."],
                correctAnswer: "b) Sí, ya están obsoletas."
            },
            {
                question: "Si se fusiona un XML con un XSLT y un Processor (Ej: Apache Xalan), ¿cuál es el resultado?",
                options: ["a) Un documento PDF.", "b) Otro documento de marcas.", "c) Una imagen.", "d) Un objeto de negocio en memoria."],
                correctAnswer: "b) Otro documento de marcas."
            },
            {
                question: "Con XSLFO (Formating Object) y un procesador (Ej: Apache FOP), el resultado de fusionar un XML sería:",
                options: ["a) Otro documento XML.", "b) Un documento de marcas.", "c) Un entregable (PDF, imagen, etc).", "d) Un archivo de configuración."],
                correctAnswer: "c) Un entregable (PDF, imagen, etc)."
            },
            {
                question: "¿Cuál es el API de programación de XML que es un estándar de la W3C y que, según el documento, \"ya nadie lo usa\"?",
                options: ["a) SAX", "b) JAXB", "c) DOM", "d) StAX"],
                correctAnswer: "c) DOM"
            },
            {
                question: "¿Qué genera el Parser DOM a partir del XML?",
                options: ["a) Un flujo de eventos.", "b) Un árbol de objetos en memoria.", "c) Clases de negocio.", "d) Un fichero de texto plano."],
                correctAnswer: "b) Un árbol de objetos en memoria."
            },
            {
                question: "¿Cuál es la principal desventaja del API DOM cuando el XML es grande?",
                options: ["a) Es muy lento.", "b) No permite modificar el árbol.", "c) Puede llegar a ocupar mucha memoria.", "d) No es compatible con todos los navegadores."],
                correctAnswer: "c) Puede llegar a ocupar mucha memoria."
            },
            {
                question: "Todos los nodos en DOM son de tipo/interface Node, pero también existen especializaciones. ¿Cuál de las siguientes NO es una especialización de Node mencionada?",
                options: ["a) Element", "b) Attribute", "c) Text", "d) Document"],
                correctAnswer: "b) Attribute (la especialización es Attr)"
            },
            {
                question: "¿Cuál de las especializaciones de Node en DOM se considera de tipo instrumental y representa a todo el documento, no siendo un nodo real del árbol?",
                options: ["a) Element", "b) Attr", "c) Text", "d) Document"],
                correctAnswer: "d) Document"
            },
            {
                question: "¿Cuál es el parser DOM de Java?",
                options: ["a) SAXParser", "b) DocumentBuilder", "c) JAXBContext", "d) XMLStreamReader"],
                correctAnswer: "b) DocumentBuilder"
            },
            {
                question: "¿Qué estándar existe para \"seleccionar\" nodos de un XML, similar a CSS Selectors?",
                options: ["a) XSLT", "b) XPath", "c) XQuery", "d) XSD"],
                correctAnswer: "b) XPath"
            },
            {
                question: "¿De qué mundo es el API SAX?",
                options: ["a) Microsoft .NET", "b) Python", "c) Java", "d) PHP"],
                correctAnswer: "c) Java"
            },
            {
                question: "¿Cómo funciona el Parser SAX con el XML?",
                options: ["a) Genera un árbol de objetos en memoria para su recorrido.", "b) Lee el XML y envía eventos a una clase previamente definida.", "c) Permite la modificación directa del documento XML.", "d) Valida el documento contra un esquema."],
                correctAnswer: "b) Lee el XML y envía eventos a una clase previamente definida."
            },
            {
                question: "¿Cuál es la principal limitación de SAX en cuanto al recorrido del documento?",
                options: ["a) Permite un recorrido bidireccional limitado.", "b) No permite ningún tipo de recorrido (funciona forward-only).", "c) Solo permite recorrer los elementos, no los atributos.", "d) Solo permite recorrer el documento una vez."],
                correctAnswer: "b) No permite ningún tipo de recorrido (funciona forward-only)."
            },
            {
                question: "¿Cuál es la ventaja de SAX frente a otros métodos de procesamiento de XML?",
                options: ["a) Es el más flexible.", "b) Es el más fácil de desarrollar.", "c) Es el más rápido.", "d) Permite manipular el documento."],
                correctAnswer: "c) Es el más rápido."
            },
            {
                question: "¿Cuál es el parser SAX de Java?",
                options: ["a) DocumentBuilder", "b) SAXParser", "c) JAXBContext", "d) XMLReader"],
                correctAnswer: "b) SAXParser"
            },
            {
                question: "¿Cuál es la principal diferencia entre JAXB y DOM en cuanto a los objetos que genera el parser?",
                options: ["a) JAXB genera objetos de Element y Attr, mientras que DOM genera clases de negocio.", "b) JAXB genera clases de negocio, mientras que DOM genera objetos de Element, Attr, etc.", "c) Ambos generan objetos idénticos.", "d) JAXB no genera objetos, solo eventos."],
                correctAnswer: "b) JAXB genera clases de negocio, mientras que DOM genera objetos de Element, Attr, etc."
            },
            {
                question: "¿Qué utilidad de la JDK permite generar automáticamente clases de negocio para JAXB a partir de un XSD?",
                options: ["a) javac", "b) jar", "c) xjc", "d) java"],
                correctAnswer: "c) xjc"
            },
            {
                question: "¿Qué es StAX, según la descripción proporcionada?",
                options: ["a) Una variante de SAX.", "b) Una variante de JAXB.", "c) Un nuevo estándar W3C para XML.", "d) Un lenguaje de transformación XML."],
                correctAnswer: "b) Una variante de JAXB."
            },
            {
                question: "¿Para qué sirve StAX principalmente?",
                options: ["a) Para generar documentos PDF.", "b) Para realizar validación de esquemas.", "c) Para hacer streaming (lectura bajo demanda por trozos).", "d) Para transformar XML a HTML."],
                correctAnswer: "c) Para hacer streaming (lectura bajo demanda por trozos)."
            },
            {
                question: "¿Cuál es el proceso de leer el XML y levantar el árbol de objetos de negocio en memoria en JAXB?",
                options: ["a) Marshall", "b) Unmarshall", "c) Parsing", "d) Serialization"],
                correctAnswer: "b) Unmarshall"
            },
            {
                question: "¿Cuál es el proceso de llevar el árbol de objetos de negocio a su XML correspondiente en JAXB?",
                options: ["a) Unmarshall", "b) Parsing", "c) Marshall", "d) Deserialization"],
                correctAnswer: "c) Marshall"
            },
            {
                question: "El proceso de Marshall en JAXB es sinónimo de:",
                options: ["a) Deserializar", "b) Serializar", "c) Compilar", "d) Interpretar"],
                correctAnswer: "b) Serializar"
            },
            {
                question: "El proceso de Unmarshall en JAXB es sinónimo de:",
                options: ["a) Serializar", "b) Deserializar", "c) Compilar", "d) Interpretar"],
                correctAnswer: "b) Deserializar"
            },
            {
                question: "¿Para qué suelen usarse los lenguajes de marca ligeros?",
                options: ["a) Para comunicaciones de alta velocidad entre servidores.", "b) Para generar documentación de forma atractiva para la web.", "c) Para la definición de esquemas de bases de datos.", "d) Para el desarrollo de aplicaciones móviles nativas."],
                correctAnswer: "b) Para generar documentación de forma atractiva para la web."
            },
            {
                question: "¿Cuál de los siguientes es un ejemplo de lenguaje de marca ligero mencionado en el documento?",
                options: ["a) XML", "b) HTML", "c) Markdown (.md)", "d) SGML"],
                correctAnswer: "c) Markdown (.md)"
            },
            {
                question: "¿Qué significa JSON?",
                options: ["a) Java Object Notation", "b) JavaScript Object Network", "c) JavaScript Object Notation", "d) Joint Standard Object Naming"],
                correctAnswer: "c) JavaScript Object Notation"
            },
            {
                question: "¿Cuál es el tipo MIME de JSON?",
                options: ["a) text/xml", "b) application/xml", "c) application/json", "d) text/plain"],
                correctAnswer: "c) application/json"
            },
            {
                question: "¿JSON es un lenguaje Schema-less por defecto?",
                options: ["a) No, siempre requiere un esquema.", "b) Sí, por defecto no se busca garantizar su validez.", "c) Solo si se utiliza con JavaScript.", "d) Depende de la implementación."],
                correctAnswer: "b) Sí, por defecto no se busca garantizar su validez."
            },
            {
                question: "¿Qué iniciativa busca crear una gramática para validar el documento JSON?",
                options: ["a) JSON-LD", "b) JSON Schema", "c) JSON API", "d) JSON-RPC"],
                correctAnswer: "b) JSON Schema"
            },
            {
                question: "¿Para qué se utiliza JSON muy a menudo?",
                options: ["a) Diseño de interfaces gráficas.", "b) Intercambio de datos.", "c) Cifrado de información.", "d) Definición de estilos CSS."],
                correctAnswer: "b) Intercambio de datos."
            },
            {
                question: "¿Cuáles son los tipos de datos básicos de JSON?",
                options: ["a) Object, String, Number, Date, Boolean.", "b) Object, Array, Number, String, true, false y null.", "c) Element, Attribute, Text, Document.", "d) Integer, Float, Double, Char."],
                correctAnswer: "b) Object, Array, Number, String, true, false y null."
            },
            {
                question: "En JSON, ¿qué representa el tipo de dato Object?",
                options: ["a) Un solo valor.", "b) Una lista ordenada de valores.", "c) Un conjunto de atributos (clave-valor).", "d) Un tipo de dato numérico."],
                correctAnswer: "c) Un conjunto de atributos (clave-valor)."
            },
            {
                question: "¿Cuál de las siguientes librerías se menciona como popular para procesar JSON?",
                options: ["a) Xerxes", "b) Apache FOP", "c) Jackson", "d) Xalan"],
                correctAnswer: "c) Jackson"
            },
            {
                question: "¿Cuáles son las API's de programación mencionadas para JSON?",
                options: ["a) JSON-DOM y JSON-SAX.", "b) JSON-B (alto nivel) y JSON-P (bajo nivel).", "c) JSON-XML y JSON-HTML.", "d) JSON-API y JSON-RPC."],
                correctAnswer: "b) JSON-B (alto nivel) y JSON-P (bajo nivel)."
            },
            {
                question: "En JSON, ¿cómo deben ir siempre los atributos?",
                options: ["a) Sin comillas.", "b) Entre comillas simples.", "c) Entre comillas dobles.", "d) Pueden ir con o sin comillas."],
                correctAnswer: "c) Entre comillas dobles."
            },
            {
                question: "Si el valor de un atributo en JSON es de tipo cadena, ¿cómo debe ir?",
                options: ["a) Sin comillas.", "b) Entre comillas simples.", "c) Entre comillas dobles.", "d) El tipo cadena no es permitido como valor."],
                correctAnswer: "c) Entre comillas dobles."
            },
            {
                question: "¿Cómo se representan las fechas en JSON?",
                options: ["a) Como un tipo de dato date específico.", "b) Como un tipo de dato datetime específico.", "c) Como cadenas, entre comillas.", "d) Como números enteros representando timestamps."],
                correctAnswer: "c) Como cadenas, entre comillas."
            },
            {
                question: "¿Cuál de los siguientes tipos de datos no lleva comillas en JSON?",
                options: ["a) String", "b) Number", "c) Object", "d) Array"],
                correctAnswer: "b) Number"
            },
            {
                question: "¿Cuál es el separador decimal en JSON?",
                options: ["a) Coma (,)", "b) Punto (.)", "c) Guion (-)", "d) Espacio ()"],
                correctAnswer: "b) Punto (.)"
            },
            {
                question: "¿Cuál es el separador de elementos en un array JSON?",
                options: ["a) Punto y coma (;)", "b) Dos puntos (:)", "c) Coma (,)", "d) Barra (/)"],
                correctAnswer: "c) Coma (,)"
            },
            {
                question: "¿Qué significa NaN en JSON?",
                options: ["a) Not an Array", "b) Not a Number", "c) Null and None", "d) New Anonymous Node"],
                correctAnswer: "b) Not a Number"
            },
            {
                question: "¿Se permiten comentarios en JSON?",
                options: ["a) Sí, utilizando ``.", "b) Sí, utilizando //.", "c) Sí, utilizando /* */.", "d) No, no hay comentarios en JSON."],
                correctAnswer: "d) No, no hay comentarios en JSON."
            },
            {
                question: "¿En qué ámbito tiene un uso muy importante JSON, especialmente para autenticación web?",
                options: ["a) Procesamiento de imágenes.", "b) Sistemas de gestión de bases de datos.", "c) Seguridad (JWT).", "d) Edición de video."],
                correctAnswer: "c) Seguridad (JWT)."
            },
            {
                question: "¿Qué significa el acrónimo recursivo YAML?",
                options: ["a) Yet Another Markup Language.", "b) YAML Ain't Markup Language.", "c) XML And Markup Language.", "d) Your Awesome Markup Logic."],
                correctAnswer: "b) YAML Ain't Markup Language."
            },
            {
                question: "¿Cuál de los siguientes es un uso mencionado para YAML?",
                options: ["a) Crear hojas de estilo CSS.", "b) Definir la lógica de aplicaciones móviles.", "c) Definir un playbook de Ansible.", "d) Desarrollar algoritmos de inteligencia artificial."],
                correctAnswer: "c) Definir un playbook de Ansible."
            },
            {
                question: "¿Se utiliza YAML para definir el entorno de trabajo de un desarrollador en DockerCompose?",
                options: ["a) No, solo XML.", "b) Sí.", "c) Solo JSON.", "d) Depende de la versión de DockerCompose."],
                correctAnswer: "b) Sí."
            },
            {
                question: "En JSON Schema, ¿qué indica \"additionalProperties\": true?",
                options: ["a) Que todas las propiedades deben ser adicionales.", "b) Que se permiten propiedades no definidas explícitamente.", "c) Que solo las propiedades obligatorias son permitidas.", "d) Que no se permiten propiedades adicionales."],
                correctAnswer: "b) Que se permiten propiedades no definidas explícitamente."
            },
            {
                question: "En JSON Schema, ¿qué indica la propiedad \"required\": [\"name\", \"artist\"]?",
                options: ["a) Que name y artist son propiedades opcionales.", "b) Que name y artist deben ser siempre cadenas de texto.", "c) Que name y artist son propiedades obligatorias.", "d) Que name y artist pueden ser nulos."],
                correctAnswer: "c) Que name y artist son propiedades obligatorias."
            },
            {
                question: "En JSON Schema, ¿qué indica el uso de \"$ref\": \"#/$defs/dimension\"?",
                options: ["a) Una referencia a un archivo externo.", "b) Una definición de tipo de dato local.", "c) Una referencia a una definición de esquema reutilizable.", "d) Una forma de incluir comentarios."],
                correctAnswer: "c) Una referencia a una definición de esquema reutilizable."
            },
            {
                question: "En JSON Schema, para una propiedad, ¿qué indica \"enum\": [\"oil\", \"watercolor\"]?",
                options: ["a) Que el valor debe ser un tipo de enumeración.", "b) Que solo se permiten los valores ''oil'' o ''watercolor''.", "c) Que el valor es una cadena de texto.", "d) Que el valor es una lista de opciones."],
                correctAnswer: "b) Que solo se permiten los valores ''oil'' o ''watercolor''."
            },
            {
                question: "En JSON Schema, ¿qué indica \"minimum\": 1 para una propiedad numérica?",
                options: ["a) Que el valor mínimo es 1, pero puede ser 0.", "b) Que el valor debe ser exactamente 1.", "c) Que solo se permiten números positivos (mayor o igual a 1).", "d) Que el valor es opcional."],
                correctAnswer: "c) Que solo se permiten números positivos (mayor o igual a 1)."
            },
            {
                question: "¿Cuál de las siguientes es una característica de XPath?",
                options: ["a) Un lenguaje para transformar XML a HTML.", "b) Un lenguaje para seleccionar nodos de un XML.", "c) Un lenguaje para definir esquemas XML.", "d) Un API para procesar XML en Java."],
                correctAnswer: "b) Un lenguaje para seleccionar nodos de un XML."
            },
            {
                question: "En XPath, ¿cómo se seleccionan todos los elementos p?",
                options: ["a) p", "b) //p", "c) p>", "d) p:*"],
                correctAnswer: "b) //p"
            },
            {
                question: "En XPath, ¿cómo se seleccionan todos los elementos hijos directos de un elemento p?",
                options: ["a) //p/*", "b) p>", "c) p:*", "d) //p/"],
                correctAnswer: "a) //p/*"
            },
            {
                question: "En XPath, ¿cómo se selecciona un elemento con un atributo llamado title?",
                options: ["a) [title]", "b) //*[@title]", "c) title", "d) //title"],
                correctAnswer: "b) //*[@title]"
            },
            {
                question: "¿Cuál es la forma en CSS3 de seleccionar un elemento por su ID?",
                options: ["a) [id='foo']", "b) //id='foo'", "c) #foo", "d) .foo"],
                correctAnswer: "c) #foo"
            },
            {
                question: "En CSS3, ¿cómo se selecciona un elemento por su clase foo?",
                options: ["a) [class='foo']", "b) //class='foo'", "c) #foo", "d) .foo"],
                correctAnswer: "d) .foo"
            },
            {
                question: "En XPath, ¿cómo se selecciona el primer hijo de todos los elementos p?",
                options: ["a) //p/*[0]", "b) p>*:first-child", "c) //p[0]", "d) p/*[1]"],
                correctAnswer: "d) p/*[1]"
            },
            {
                question: "¿Es posible en CSS3 seleccionar todos los elementos p que tienen un hijo a?",
                options: ["a) Sí, con p a.", "b) No, no es posible.", "c) Sí, con p:has(a).", "d) Sí, con p > a."],
                correctAnswer: "b) No, no es posible." // Based on the provided answer key, CSS3 does not have :has() selector directly.
            },
            {
                question: "En XPath, ¿cómo se selecciona el siguiente elemento hermano de un elemento p?",
                options: ["a) p+", "b) //p/following-sibling::*[0]", "c) p~*", "d) p/next()"],
                correctAnswer: "b) //p/following-sibling::*[0]"
            },
            {
                question: "¿Es posible en CSS3 seleccionar el elemento hermano anterior?",
                options: ["a) Sí, con p-.", "b) No, no es posible.", "c) Sí, con p:prev().", "d) Sí, con p<."],
                correctAnswer: "b) No, no es posible."
            },
            {
                question: "¿Qué indica el atributo use=\"required\" en una definición de atributo en un esquema XML (XSD)?",
                options: ["a) Que el atributo es opcional.", "b) Que el atributo es obligatorio.", "c) Que el atributo tiene un valor por defecto.", "d) Que el atributo no debe estar presente."],
                correctAnswer: "b) Que el atributo es obligatorio."
            },
            {
                question: "En un XSD, ¿qué indica type=\"xs:time\" para un elemento?",
                options: ["a) Que el elemento contiene un valor booleano.", "b) Que el elemento contiene una cadena de texto.", "c) Que el elemento contiene un valor de tiempo.", "d) Que el elemento contiene una fecha."],
                correctAnswer: "c) Que el elemento contiene un valor de tiempo."
            }
        ];

                // Variables de estado del quiz
        let currentQuestionIndex = 0;
        let score = 0;
        // userAnswers guarda el texto de la opción seleccionada (o null)
        // Corregido: Usar quizData.length en lugar de questions.length
        const userAnswers = new Array(quizData.length).fill(null);
        // scoredQuestions guarda true si la pregunta fue respondida correctamente, false si fue incorrecta o no respondida
        // Corregido: Usar quizData.length en lugar de questions.length
        const scoredQuestions = new Array(quizData.length).fill(false); 

        // Referencias a los elementos del DOM
        const quizContainer = document.getElementById('quizContainer');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const restartBtn = document.getElementById('restartBtn');
        const restartInlineBtn = document.getElementById('restartInlineBtn');
        const finalScoreDiv = document.getElementById('finalScore');
        const progressBar = document.getElementById('progressBar');
        const finalScoreDisplay = finalScoreDiv.querySelector('.score-display');
        const correctCountSpan = document.getElementById('correctCount');
        const incorrectCountSpan = document.getElementById('incorrectCount');
        const unansweredCountSpan = document.getElementById('unansweredCount');

        /**
         * Carga el estado del quiz guardado en localStorage.
         * Si no existe, inicializa un nuevo estado.
         */
        function loadQuizState() {
            try {
                const savedState = JSON.parse(localStorage.getItem('quizState'));
                if (savedState) {
                    currentQuestionIndex = savedState.currentQuestionIndex;
                    score = savedState.score;
                    // Asegurarse de que los arrays tengan el tamaño correcto y copiar los valores
                    userAnswers.splice(0, savedState.userAnswers.length, ...savedState.userAnswers);
                    scoredQuestions.splice(0, savedState.scoredQuestions.length, ...savedState.scoredQuestions);
                }
            } catch (e) {
                console.error("Error al cargar el estado del quiz:", e);
                // Si hay un error, el estado se reiniciará a los valores por defecto
            }
        }

        /**
         * Guarda el estado actual del quiz en localStorage.
         */
        function saveQuizState() {
            const quizState = {
                currentQuestionIndex: currentQuestionIndex,
                score: score,
                userAnswers: userAnswers,
                scoredQuestions: scoredQuestions
            };
            localStorage.setItem('quizState', JSON.stringify(quizState));
        }

        /**
         * Carga y muestra la pregunta actual.
         */
        function loadQuestion() {
            // Corregido: Usar quizData.length en lugar de questions.length
            if (currentQuestionIndex >= quizData.length) {
                showResults();
                return;
            }

            // Corregido: Usar quizData en lugar de questions
            const currentQuestion = quizData[currentQuestionIndex];
            quizContainer.innerHTML = `
                <div class="question-card">
                    <p class="question-text"></p>
                    <div class="options-container">
                        ${currentQuestion.options.map(() => `
                            <button class="option-button"></button>
                        `).join('')}
                    </div>
                    <div class="solution hidden">
                        <strong>Solución:</strong> <span class="solution-text"></span>
                    </div>
                </div>
            `;

            const questionTextElement = quizContainer.querySelector('.question-text');
            const optionsContainer = quizContainer.querySelector('.options-container');
            const questionCard = quizContainer.querySelector('.question-card');
            const optionButtons = optionsContainer.querySelectorAll('.option-button');

            // Usar textContent para insertar el texto de la pregunta de forma segura
            questionTextElement.textContent = `${currentQuestionIndex + 1}. ${currentQuestion.question}`;

            // Asignar el texto y los atributos data-option a cada botón de opción
            currentQuestion.options.forEach((option, index) => {
                optionButtons[index].textContent = option; // Inserta el texto como texto plano
                optionButtons[index].dataset.option = option; // Guarda la opción original para la lógica
                optionButtons[index].addEventListener('click', handleOptionClick);
            });

            // Resalta la respuesta del usuario si ya ha respondido y aplica estilos
            const savedAnswer = userAnswers[currentQuestionIndex];
            if (savedAnswer !== null) {
                // Encuentra el botón por su atributo data-option, que contiene la respuesta guardada
                const selectedButton = optionsContainer.querySelector(`[data-option="${savedAnswer}"]`);
                if (selectedButton) {
                    // Deshabilita todos los botones para que no se pueda cambiar la respuesta
                    optionButtons.forEach(button => {
                        button.classList.add('disabled');
                        button.removeEventListener('click', handleOptionClick); // Remover listener si ya está respondida
                    });

                    // Aplica los estilos de la respuesta guardada
                    const isCorrect = (savedAnswer === currentQuestion.correctAnswer);
                    if (isCorrect) {
                        selectedButton.classList.add('correct-answer');
                        questionCard.classList.add('correct');
                    } else {
                        selectedButton.classList.add('incorrect-answer');
                        questionCard.classList.add('incorrect');
                        // Muestra la respuesta correcta si la guardada fue incorrecta
                        const correctButton = optionsContainer.querySelector(`[data-option="${currentQuestion.correctAnswer}"]`);
                        if (correctButton) {
                            correctButton.classList.add('correct-answer');
                        }
                    }
                    // Añadir feedback visual (Correcto/Incorrecto)
                    updateQuestionCardVisuals(isCorrect);
                }
            }

            // Actualiza el estado de los botones de navegación y la barra de progreso
            updateNavButtons();
            updateProgressBar();
        }

        /**
         * Maneja el evento de clic en una opción de respuesta.
         * @param {Event} event - El evento de clic.
         */
        function handleOptionClick(event) {
            const selectedOptionButton = event.target;
            const selectedOption = selectedOptionButton.dataset.option; // Obtiene la opción del atributo data-option
            // Corregido: Usar quizData en lugar de questions
            const currentQuestion = quizData[currentQuestionIndex];
            const optionsContainer = quizContainer.querySelector('.options-container');
            const questionCard = quizContainer.querySelector('.question-card');

            // Deshabilita todos los botones de opción para evitar múltiples respuestas
            optionsContainer.querySelectorAll('.option-button').forEach(button => {
                button.classList.add('disabled');
                button.removeEventListener('click', handleOptionClick);
            });

            // Actualiza la respuesta del usuario y la guarda
            userAnswers[currentQuestionIndex] = selectedOption;
            
            // Comprueba si la respuesta es correcta
            const isCorrectAttempt = (selectedOption === currentQuestion.correctAnswer);

            if (isCorrectAttempt) {
                selectedOptionButton.classList.add('correct-answer');
                questionCard.classList.add('correct');
                // Si no se ha puntuado antes, añade un punto y marca como correcta
                if (!scoredQuestions[currentQuestionIndex]) { // scoredQuestions[index] will be false if not yet scored
                    score++;
                    scoredQuestions[currentQuestionIndex] = true; // Marca como correcta
                }
            } else {
                selectedOptionButton.classList.add('incorrect-answer');
                questionCard.classList.add('incorrect');
                // Si se había puntuado como correcta (porque el usuario cambió de opinión), quita el punto
                if (scoredQuestions[currentQuestionIndex]) { // scoredQuestions[index] will be true if it was previously correct
                    score--;
                    scoredQuestions[currentQuestionIndex] = false; // Marca como incorrecta
                }
                // Resalta la respuesta correcta
                const correctAnswerButton = optionsContainer.querySelector(`[data-option="${currentQuestion.correctAnswer}"]`);
                if (correctAnswerButton) {
                    correctAnswerButton.classList.add('correct-answer');
                }
            }
            
            saveQuizState(); // Guarda el estado después de actualizar score y scoredQuestions

            // Añadir feedback visual (Correcto/Incorrecto)
            updateQuestionCardVisuals(isCorrectAttempt);

            // Muestra la solución detallada si existe (aunque no hay en tu questions actual)
            if (currentQuestion.solution) {
                const solutionDiv = quizContainer.querySelector('.solution');
                solutionDiv.classList.remove('hidden');
                solutionDiv.querySelector('.solution-text').textContent = currentQuestion.solution;
            }
        }

        /**
         * Actualiza el estilo de la tarjeta de pregunta y añade feedback visual.
         * @param {boolean} isCorrect - Indica si la respuesta es correcta.
         */
        function updateQuestionCardVisuals(isCorrect) {
            const questionCard = document.querySelector('.question-card');
            // Eliminar feedback anterior si existe
            const existingFeedback = questionCard.querySelector('.feedback');
            if (existingFeedback) {
                existingFeedback.remove();
            }

            const feedbackMessage = document.createElement('p');
            feedbackMessage.classList.add('feedback');

            if (isCorrect) {
                feedbackMessage.textContent = '¡Correcto!';
                feedbackMessage.classList.add('correct');
            } else {
                feedbackMessage.textContent = 'Incorrecto. La respuesta correcta es la marcada en verde.';
                feedbackMessage.classList.add('incorrect');
            }
            questionCard.appendChild(feedbackMessage);
        }

        /**
         * Muestra los resultados finales del quiz.
         */
        function showResults() {
            quizContainer.classList.add('hidden');
            prevBtn.classList.add('hidden');
            nextBtn.classList.add('hidden');
            restartInlineBtn.classList.add('hidden');
            progressBar.parentElement.classList.add('hidden');
            finalScoreDiv.classList.remove('hidden');

            // Calcula y muestra las estadísticas
            const correctAnswers = scoredQuestions.filter(isCorrect => isCorrect).length;
            // Una respuesta es incorrecta si el usuario respondió (no es null) Y no fue marcada como correcta (scoredQuestions[index] es false)
            const incorrectAnswers = userAnswers.filter((answer, index) => answer !== null && !scoredQuestions[index]).length;
            const unansweredQuestions = userAnswers.filter(answer => answer === null).length;

            // Corregido: Usar quizData.length en lugar de questions.length
            finalScoreDisplay.textContent = `Tu puntuación final es ${correctAnswers} de ${quizData.length}`;
            correctCountSpan.textContent = correctAnswers;
            incorrectCountSpan.textContent = incorrectAnswers;
            unansweredCountSpan.textContent = unansweredQuestions;
        }
		
        /**
         * Actualiza el estado de los botones de navegación.
         */
        function updateNavButtons() {
            prevBtn.disabled = currentQuestionIndex === 0;
            // Corregido: Usar quizData.length en lugar de questions.length
            nextBtn.textContent = currentQuestionIndex === quizData.length - 1 ? 'Finalizar' : 'Siguiente';
        }

        /**
         * Actualiza la barra de progreso.
         */
        function updateProgressBar() {
            // Corregido: Usar quizData.length en lugar de questions.length
            const progress = ((currentQuestionIndex + 1) / quizData.length) * 100;
            progressBar.style.width = `${progress}%`;
        }

        /**
         * Reinicia el quiz a su estado inicial.
         */
        function restartQuiz() {
            currentQuestionIndex = 0;
            score = 0;
            userAnswers.fill(null);
            scoredQuestions.fill(false);
            localStorage.clear(); // Limpia el localStorage
            
            quizContainer.classList.remove('hidden');
            prevBtn.classList.remove('hidden');
            nextBtn.classList.remove('hidden');
            restartInlineBtn.classList.remove('hidden');
            progressBar.parentElement.classList.remove('hidden');
            finalScoreDiv.classList.add('hidden');
            loadQuestion();
        }

        // Event listeners
        prevBtn.addEventListener('click', () => {
            if (currentQuestionIndex > 0) {
                currentQuestionIndex--;
                loadQuestion();
            }
        });

        nextBtn.addEventListener('click', () => {
            // Corregido: Usar quizData.length en lugar de questions.length
            if (currentQuestionIndex < quizData.length - 1) {
                currentQuestionIndex++;
                loadQuestion();
            } else {
                showResults();
            }
        });

        restartBtn.addEventListener('click', restartQuiz);
        restartInlineBtn.addEventListener('click', restartQuiz);

        // Carga inicial
        window.onload = function() {
            loadQuizState();
            loadQuestion();
        };
    </script>
</body>
</html>
